# Unlink Exploit

In the unlink exploit, the goal is to exploit the following macro:

```c
#define unlink(AV, P, BK, FD) {                                            \
    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \
      malloc_printerr ("corrupted size vs. prev_size");                              \
    FD = P->fd;                                                                      \
    BK = P->bk;                                                                      \
    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \
      malloc_printerr ("corrupted double-linked list");                              \
    else {                                                                      \
        FD->bk = BK;                                                              \
        BK->fd = FD;                                                              \
        if (!in_smallbin_range (chunksize_nomask (P))                              \
            && __builtin_expect (P->fd_nextsize != NULL, 0)) {                      \
            if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)              \
                || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \
              malloc_printerr ("corrupted double-linked list (not small)");   \
            if (FD->fd_nextsize == NULL) {                                      \
                if (P->fd_nextsize == P)                                      \
                  FD->fd_nextsize = FD->bk_nextsize = FD;                      \
                else {                                                              \
                    FD->fd_nextsize = P->fd_nextsize;                              \
                    FD->bk_nextsize = P->bk_nextsize;                              \
                    P->fd_nextsize->bk_nextsize = FD;                              \
                    P->bk_nextsize->fd_nextsize = FD;                              \
                  }                                                              \
              } else {                                                              \
                P->fd_nextsize->bk_nextsize = P->bk_nextsize;                      \
                P->bk_nextsize->fd_nextsize = P->fd_nextsize;                      \
              }                                                                      \
          }                                                                      \
      }                                                                              \
}
```

The unlink macro removes a chunk from a bin.  

```c
FD->bk = BK;                                                              \
BK->fd = FD;
```

### Consolidate Backwards

glibc likes to keep the heap tidy, as I've been told, so if two adjacent chunks in memory are both free, why not merge them?  This action happens through the prev\_inuse 

```c
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
```

```c
    /* consolidate backward */
    // Is the previous chunk free?
    if (!prev_inuse(p)) {
      prevsize = prev_size (p);
       // add previous chunk size to current size
      size += prevsize;
       // move data pointer back to merge both chunks
       // i.e. change chunk pointer to point to current chunk
      p = chunk_at_offset(p, -((long) prevsize));
      // unlink from from the bin
      
      unlink(av, p, bck, fwd);
    }
```

This chunk is then placed within the unsorted chunk list, as it is given a chance to be re-allocated before being placed in a regular bin.





