# Stack Canaries

```text
mov    rcx,QWORD PTR [rbp-0x8]
xor    rcx,QWORD PTR fs:0x28
je     0xc5c <rand_function+237>
call   0x920 <__stack_chk_fail@plt>
leave
ret
```

In this case the stack canary is at `rbp-0x8`, just adjacent to the frame pointer.  If we overwrite a buffer, we'll overwrite this and the xor comparison will fail, resulting in an early exit from the program.

## Bypasses

A good starting point is to identify the system the binary is run on.  Stack canaries for at least Ubuntu systems begin with a null-byte.  This is intended to cut several exploitation techniques in their tracks, depending on how the data is read, as a null-byte will signify the end of a string for many C functions.

### Information Leak

### Stack Reading

The fundamental principle of stack-reading involves writing individual bytes to the end of a buffer, assuming nothing is appended to the input via i.e. read.  If any values are appended to the end of a payload, then this attack is no longer viable as more than the intended bytes will be overwritten:

![An illustration of the stack-reading exploit. ](../../.gitbook/assets/image.png)

Source: [NCC Group - Blind Return Oriented Programming](https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2015/june/blind-return-oriented-programming/)

I usually use the following code to perform a stack-reading attack:

```python
def stack_read(payload, run):  
    if run > 8: 
        return payload[-8:] 
    for i in range(0, 256): 
        x = chr(i) 
        topush = payload + x 
        res = exploit(topush) 
        if res == None: 
            continue 
        else: 
            print repr(x) 
            return stack_read(topush, run+1) 
```

Things to consider are that it is not generic, is designed for 64-bit systems and assumes that the function exploit will return a `None` type in the event of failure.  Consequently, the failure condition must be known, and must exist outside the overflown stack frame.

What's interesting about this method is that it can also be used to achieve a stack address leak in the event of ASLR and a binary address leak in the event of PIE.

#### Leak Binary/Stack Address

Since RBP/EBP directly follows the canary, once we hit this we can perform the same stack reading but on the RBP/EBP value.  This of course assumes that our failure/success state is predicated on a corrupted stack, as it would have to exist in a seperate stack frame to our current.  The RBP will be at a constant offset to the stack start in most cases and therefore can be used to predict the current location of the stack.

The same follows but for EIP.  This can be more difficult as there can be many addresses which won't outright crash the program, but assuming the same success/failure state is quite simple.  Further, the last byte is not subject to ASLR/PIE so this means only 7 bytes need to be calculated.

 

