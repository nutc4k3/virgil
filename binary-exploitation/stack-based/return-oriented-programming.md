# Return Oriented Programming

> With data execution prevention, an adversary cannot execute maliciously injected instructions because a typical buffer overflow overwrites contents in the data section of memory, which is marked as non-executable. To defeat this, a return-oriented programming attack does not inject malicious code, but rather uses instructions that are already present, called "gadgets", by manipulating return addresses.

[Wikipedia - Return-oriented programming](https://en.wikipedia.org/wiki/Return-oriented_programming)



## ret2libc

The following set of techniques require either a libc address leak, or no ASLR enabled on the system.

### ret2mprotect

### ret2system

This involves formin

## PLT & GOT

Here we're going to take a quick aside and talk about the Procedure Linkage Table and the Global Offsets Table, two methods of compilation that allow modern binary protections to work, but can also be abused in certain ways to bypass these protections.

### Procedure Linkage Table \(PLT\)

### Global Offsets Table \(GOT\)

## Common Primitives

Actually locating useful gadgets is the crux of return-oriented programming and sometimes actually finding these gadgets is harder than you initially may realise.  In this section I will describe some common techniques for either populating registers or manipulating the stack into a manner to ease exploitation.

### \_\_libc\_csu\_init

This is appropriate in a situation where ASLR is enabled, but either PIE isn't or the binary base address is known.  It utilises common gadgets found within most gcc compiled binaries.  A full description is available in [return-to-csu: A New Method to Bypass 64-bit Linux ASLR](https://www.blackhat.com/docs/asia-18/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR-wp.pdf).

Within the function \_\_libc\_csu\_init the following gadget chains are found.  Since rdi, rsi and rdx are controllable via the other registers, and r12 and rbx are also controllable we can see the registers accordingly and call a chosen function after.  This will likely be a function within the PLT.

```text
   0x0000555555554f50 <+64>:	mov    rdx,r15
   0x0000555555554f53 <+67>:	mov    rsi,r14
   0x0000555555554f56 <+70>:	mov    edi,r13d
   0x0000555555554f59 <+73>:	call   QWORD PTR [r12+rbx*8]
```

```text
   0x0000555555554f6a <+90>:	pop    rbx
   0x0000555555554f6b <+91>:	pop    rbp
   0x0000555555554f6c <+92>:	pop    r12
   0x0000555555554f6e <+94>:	pop    r13
   0x0000555555554f70 <+96>:	pop    r14
   0x0000555555554f72 <+98>:	pop    r15
   0x0000555555554f74 <+100>:	ret
```

In reality this is not a complex attack or even a new type of attack, but due to the nature of these gadgets they're often missed by most ROP checking tools, and they're found in a very large number binaries.

### write4

### Stack Pivot

